{% raw %}
use carbon_core::deserialize::CarbonDeserialize;
use carbon_core::instruction::InstructionDecoder;
{% endraw %}

use crate::{{ decoder_name }};

{%- for instruction in instructions %}
pub mod {{ instruction.module_name }};
{%- endfor %}
{%- for event in events %}
pub mod {{ event.module_name }};
{%- endfor %}

#[derive(carbon_proc_macros::InstructionType, serde::Serialize, PartialEq, Eq, Debug, Clone, Hash)]
pub enum {{ program_instruction_enum }} {
    {%- for instruction in instructions %}
    {{ instruction.struct_name }}({{ instruction.module_name }}::{{ instruction.struct_name }}),
    {%- endfor %}
    {%- for event in events %}
    {{ event.struct_name }}({{ event.module_name }}::{{ event.struct_name }}),
    {%- endfor %}
}

impl InstructionDecoder for {{ decoder_name }} {
    type InstructionType = {{ program_instruction_enum }};

    fn decode_instructions(
        &self,
        instruction: solana_sdk::instruction::Instruction,
    ) -> Option<carbon_core::instruction::DecodedInstruction<Self::InstructionType>> {
        {%- for instruction in instructions %}
        if let Some(decoded_instruction) = {{ instruction.module_name }}::{{ instruction.struct_name }}::deserialize(instruction.data.as_slice()) {
            return Some(carbon_core::instruction::DecodedInstruction {
                program_id: instruction.program_id,
                data: {{ program_instruction_enum }}::{{ instruction.struct_name }}(decoded_instruction),
            });
        }
        {%- endfor %}
        {%- for event in events %}
        if let Some(decoded_instruction) = {{ event.module_name }}::{{ event.struct_name }}::deserialize(instruction.data.as_slice()) {
            return Some(carbon_core::instruction::DecodedInstruction {
                program_id: instruction.program_id,
                data: {{ program_instruction_enum }}::{{ event.struct_name }}(decoded_instruction),
            });
        }
        {%- endfor %}

        None
    }
}
